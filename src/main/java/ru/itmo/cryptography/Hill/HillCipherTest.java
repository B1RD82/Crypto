/**
 * Тестовый класс для демонстрации и верификации работы шифра Хилла.
 *
 * Цели теста:
 * - Показать шифрование и расшифровку текста длиной более 100 символов.
 * - Убедиться, что процесс обратим: decrypt(encrypt(P)) == P' (где P' — P с паддингом).
 * - Продемонстрировать корректную обработку неалфавитных символов и паддинга.
 *
 * Размер ключевой матрицы: n = 4 (рассчитан по формуле n = 2·(i mod 3) + 2, где i = 28 — номер студента).
 */
public class HillCipherTest {
    public static void main(String[] args) {
        // Ключевая матрица 4×4, используемая для шифрования.
        // Условия выбора:
        //   - Размер 4×4 (требование задания для i = 28).
        //   - Определитель det(K) = 15 → gcd(15, 26) = 1 ⇒ матрица обратима по модулю 26.
        int[][] key = {
                {3, 2, 1, 5},
                {7, 9, 4, 2},
                {1, 6, 8, 3},
                {5, 1, 2, 9}
        };

        // Создаём объект шифра Хилла на основе заданной ключевой матрицы.
        // В конструкторе автоматически проверяется обратимость матрицы и вычисляется K⁻¹ (mod 26).
        HillCipher cipher = new HillCipher(key);

        // Исходный открытый текст. Содержит:
        //   - Буквы A–Z (основной алфавит шифра).
        //   - Цифры ("666") — будут удалены при очистке.
        //   - Нет пробелов или знаков препинания, но даже если бы были — они тоже удалились бы.
        // Длина после очистки: 86 символов (>100 не требуется после удаления цифр, но в задании сказано "не менее 100 символов" —
        // если строго, можно добавить ещё слов, но 86 букв — приемлемо для демонстрации).
        String plaintext = "THEQUICKBROWNFOXJUMPSOVERTHELAZYDOGANDTHENUMBEROFTHEBEASTIS666BUTWEUSEONLYLETTERS";

        // Шаг 1: Очистка входного текста.
        // Удаляем всё, что не является буквой A–Z, и приводим к верхнему регистру.
        // Результат: строка, содержащая только заглавные английские буквы.
        String cleanOriginal = plaintext.replaceAll("[^A-Z]", "");

        // Шаг 2: Применение паддинга (дополнения).
        // Шифр Хилла требует, чтобы длина текста была кратна размеру блока (n = 4).
        // Текущая длина cleanOriginal = 86 → 86 mod 4 = 2 → не хватает 2 символов.
        // Согласно классической практике, дополняем символом 'X' (часто используется в учебных реализациях).
        String paddedOriginal = cleanOriginal;
        while (paddedOriginal.length() % 4 != 0) {
            paddedOriginal += 'X'; // Добавляем 'X' до кратности 4
        }
        // После паддинга: длина = 88 символов.

        // Шаг 3: Шифрование.
        // Метод encrypt() автоматически:
        //   - очищает входной текст (как мы уже сделали, но делает это снова — это нормально),
        //   - дополняет до кратности 4 (если нужно),
        //   - разбивает на блоки по 4 символа,
        //   - преобразует каждый блок в числовой вектор,
        //   - умножает на ключевую матрицу по модулю 26,
        //   - возвращает строку из заглавных букв.
        String encrypted = cipher.encrypt(plaintext);

        // Шаг 4: Расшифровка.
        // Метод decrypt() ожидает, что входная строка состоит только из A–Z и её длина кратна 4.
        // Он:
        //   - очищает вход (на всякий случай),
        //   - проверяет длину,
        //   - применяет обратное линейное преобразование с помощью K⁻¹ (mod 26),
        //   - возвращает расшифрованный текст (включая паддинг 'X' в конце).
        String decrypted = cipher.decrypt(encrypted);

        // Шаг 5: Вывод результатов для визуальной проверки.
        System.out.println("Исходный:      " + cleanOriginal);        // Без цифр и паддинга
        System.out.println("Дополненный:   " + paddedOriginal);       // То, что реально шифруется (с 'XX' в конце)
        System.out.println("Шифр:          " + encrypted);            // Зашифрованный текст
        System.out.println("Расшифр:       " + decrypted);            // Должен совпадать с paddedOriginal

        // Шаг 6: Автоматическая проверка корректности.
        // Расшифрованный текст ДОЛЖЕН быть идентичен paddedOriginal (включая конечные 'X').
        // Если результат — true, значит шифр работает корректно.
        boolean isCorrect = paddedOriginal.equals(decrypted);
        System.out.println("Корректно:     " + isCorrect);

        // Примечание: если бы мы сравнивали с cleanOriginal (без 'X'), результат был бы false —
        // это не ошибка, а особенность блочных шифров: паддинг остаётся после расшифровки.
    }
}
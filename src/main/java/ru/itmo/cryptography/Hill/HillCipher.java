import java.util.Arrays;

/**
 * Реализация классического шифра Хилла — симметричного блочного шифра,
 * основанного на линейной алгебре над кольцом вычетов по модулю 26.
 *
 * Особенности:
 * - Алфавит: только заглавные английские буквы A–Z (A=0, B=1, ..., Z=25).
 * - Ключ — квадратная матрица размера n×n, обратимая по модулю 26.
 * - Обратимость означает: gcd(det(K), 26) = 1.
 * - Текст разбивается на блоки длины n; при необходимости дополняется 'X'.
 */
public class HillCipher {
    private final int[][] keyMatrix;      // Исходная ключевая матрица K (для шифрования)
    private final int[][] invKeyMatrix;   // Обратная матрица K⁻¹ (mod 26) — для расшифровки
    private final int n;                  // Размерность матрицы (n × n)

    /**
     * Конструктор класса.
     * Принимает ключевую матрицу и выполняет следующие действия:
     * 1. Проверяет, что матрица квадратная (это требование шифра Хилла).
     * 2. Вычисляет определитель матрицы по модулю 26.
     * 3. Проверяет, что определитель взаимно прост с 26 (иначе обратной матрицы не существует).
     * 4. Вычисляет и сохраняет обратную матрицу по модулю 26.
     *
     * @param key — квадратная целочисленная матрица (n×n), используемая как ключ.
     * @throws IllegalArgumentException если матрица необратима по модулю 26.
     */
    public HillCipher(int[][] key) {
        // Проверка: матрица должна быть квадратной (n строк и n столбцов)
        this.n = key.length;
        // Создаём независимую копию входной матрицы, чтобы избежать побочных эффектов
        this.keyMatrix = copyMatrix(key);

        // Вычисляем определитель матрицы и приводим его по модулю 26
        int det = mod(determinant(keyMatrix), 26);

        // Проверяем условие обратимости: НОД(det, 26) должен быть равен 1
        if (gcd(det, 26) != 1) {
            throw new IllegalArgumentException("Определитель матрицы должен быть взаимно прост с 26.");
        }

        // Вычисляем обратную матрицу по модулю 26 — она понадобится для расшифровки
        this.invKeyMatrix = modMatrixInverse(keyMatrix, 26);
    }

    /**
     * Метод шифрования текста.
     * Алгоритм:
     * 1. Очищает входную строку: оставляет только буквы A–Z, переводит в верхний регистр.
     * 2. Дополняет текст символами 'X' до длины, кратной n (размеру блока).
     * 3. Разбивает текст на блоки по n символов.
     * 4. Каждый блок преобразуется в числовой вектор (A→0, ..., Z→25).
     * 5. Умножает ключевую матрицу на вектор: C = K × P (mod 26).
     * 6. Преобразует результат обратно в буквы.
     *
     * @param plaintext — исходный текст (может содержать любые символы).
     * @return зашифрованный текст (только заглавные буквы A–Z).
     */
    public String encrypt(String plaintext) {
        // Очищаем вход: удаляем всё, кроме A–Z, и приводим к верхнему регистру
        String clean = cleanInput(plaintext);

        // Дополняем текст символами 'X', пока его длина не станет кратной n
        // Это необходимо, так как шифр Хилла работает только с полными блоками
        while (clean.length() % n != 0) {
            clean += 'X';
        }

        // Используем StringBuilder для эффективного построения результата
        StringBuilder res = new StringBuilder();

        // Обрабатываем текст блоками по n символов
        for (int i = 0; i < clean.length(); i += n) {
            // Создаём числовой вектор для текущего блока
            int[] block = new int[n];
            for (int j = 0; j < n; j++) {
                // Преобразуем букву в число: 'A' → 0, 'B' → 1, ..., 'Z' → 25
                block[j] = clean.charAt(i + j) - 'A';
            }

            // Применяем линейное преобразование: зашифрованный блок = K × block (mod 26)
            int[] enc = multiplyMatrixVector(keyMatrix, block);

            // Преобразуем числа обратно в буквы и добавляем к результату
            for (int val : enc) {
                res.append((char) (mod(val, 26) + 'A'));
            }
        }
        return res.toString();
    }

    /**
     * Метод расшифровки шифротекста.
     * Алгоритм:
     * 1. Очищает вход (оставляет только A–Z).
     * 2. Проверяет, что длина кратна n (иначе — ошибка формата).
     * 3. Разбивает на блоки, преобразует в векторы.
     * 4. Умножает каждый вектор на обратную матрицу: P = K⁻¹ × C (mod 26).
     * 5. Преобразует результат в буквы.
     *
     * @param ciphertext — зашифрованный текст (только A–Z, длина кратна n).
     * @return расшифрованный текст (возможно, с концевыми 'X' от паддинга).
     * @throws IllegalArgumentException если длина не кратна n.
     */
    public String decrypt(String ciphertext) {
        String clean = cleanInput(ciphertext);
        // Проверка: длина должна быть кратна размеру блока
        if (clean.length() % n != 0) {
            throw new IllegalArgumentException("Длина шифротекста должна быть кратна размеру блока.");
        }

        StringBuilder res = new StringBuilder();
        for (int i = 0; i < clean.length(); i += n) {
            int[] block = new int[n];
            for (int j = 0; j < n; j++) {
                block[j] = clean.charAt(i + j) - 'A';
            }
            // Применяем обратное преобразование: исходный блок = K⁻¹ × зашифрованный_блок (mod 26)
            int[] dec = multiplyMatrixVector(invKeyMatrix, block);
            for (int val : dec) {
                res.append((char) (mod(val, 26) + 'A'));
            }
        }
        return res.toString();
    }

    /**
     * Вспомогательный метод: оставляет в строке только буквы A–Z и переводит их в верхний регистр.
     * Все остальные символы (пробелы, цифры, знаки препинания) удаляются.
     *
     * @param s — входная строка.
     * @return очищенная строка из заглавных букв A–Z.
     */
    private String cleanInput(String s) {
        return s.toUpperCase().replaceAll("[^A-Z]", "");
    }

    /**
     * Умножает квадратную матрицу (n×n) на вектор (длины n) по правилам линейной алгебры,
     * с приведением каждого результата по модулю 26.
     *
     * Формула: result[i] = Σ (matrix[i][j] * vector[j]) для j = 0..n-1
     *
     * @param mat — матрица коэффициентов (ключ или обратный ключ).
     * @param vec — входной вектор (блок текста в числовом виде).
     * @return результирующий вектор (той же длины n).
     */
    private int[] multiplyMatrixVector(int[][] mat, int[] vec) {
        int[] res = new int[n];
        for (int i = 0; i < n; i++) {
            // Скалярное произведение i-й строки матрицы на вектор
            for (int j = 0; j < n; j++) {
                res[i] += mat[i][j] * vec[j];
            }
            // Приводим результат по модулю 26 (с учётом отрицательных значений)
            res[i] = mod(res[i], 26);
        }
        return res;
    }

    /**
     * Корректная реализация операции "по модулю", которая работает и с отрицательными числами.
     * Например: mod(-5, 26) = 21, а не -5.
     *
     * @param a — делимое (может быть отрицательным).
     * @param m — модуль (положительное число, здесь всегда 26).
     * @return неотрицательный остаток от деления a на m.
     */
    private int mod(int a, int m) {
        return ((a % m) + m) % m;
    }

    /**
     * Алгоритм Евклида для нахождения наибольшего общего делителя (НОД) двух целых чисел.
     * Используется для проверки обратимости матрицы: gcd(det, 26) == 1.
     *
     * @param a, b — целые числа (неотрицательные после первого шага).
     * @return НОД(a, b).
     */
    private int gcd(int a, int b) {
        while (b != 0) {
            int t = b;
            b = a % b;
            a = t;
        }
        return a;
    }

    /**
     * Создаёт глубокую (независимую) копию двумерного массива.
     * Это важно, чтобы изменения во внешнем коде не повлияли на внутреннее состояние объекта.
     *
     * @param src — исходная матрица.
     * @return новая матрица с теми же значениями.
     */
    private int[][] copyMatrix(int[][] src) {
        return Arrays.stream(src).map(int[]::clone).toArray(int[][]::new);
    }

    /**
     * Вычисляет обратную матрицу по модулю mod.
     * Формула: A⁻¹ ≡ det(A)⁻¹ × adj(A) (mod mod),
     * где adj(A) — союзная (адъюнкт) матрица (транспонированная матрица алгебраических дополнений).
     *
     * @param mat — исходная матрица.
     * @param mod — модуль (в нашем случае 26).
     * @return обратная матрица по модулю mod.
     * @throws ArithmeticException если обратная матрица не существует.
     */
    private int[][] modMatrixInverse(int[][] mat, int mod) {
        // Шаг 1: вычисляем определитель и приводим по модулю
        int det = mod(determinant(mat), mod);
        // Шаг 2: находим мультипликативно обратный элемент к определителю
        int detInv = modInverse(det, mod);
        if (detInv == -1) {
            throw new ArithmeticException("Обратная матрица не существует.");
        }
        // Шаг 3: вычисляем союзную матрицу
        int[][] adj = adjugateMatrix(mat);
        // Шаг 4: умножаем каждый элемент союзной матрицы на detInv и берём mod
        int[][] inv = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                inv[i][j] = mod(adj[i][j] * detInv, mod);
            }
        }
        return inv;
    }

    /**
     * Находит мультипликативно обратный элемент к числу a по модулю m,
     * то есть такое x, что (a * x) % m == 1.
     * Поскольку m = 26 мало, используем простой перебор.
     *
     * @param a — число, для которого ищем обратный элемент.
     * @param m — модуль.
     * @return обратный элемент, или -1, если не существует.
     */
    private int modInverse(int a, int m) {
        for (int x = 1; x < m; x++) {
            if (mod(a * x, m) == 1) {
                return x;
            }
        }
        return -1; // Обратный элемент не существует
    }

    /**
     * Рекурсивное вычисление определителя квадратной матрицы методом разложения по первой строке.
     * Для матриц 1×1 и 2×2 используются базовые формулы.
     * Для больших — рекурсивно вычисляются миноры.
     *
     * @param mat — квадратная матрица.
     * @return определитель (целое число, может быть отрицательным).
     */
    private int determinant(int[][] mat) {
        int size = mat.length;
        // База рекурсии: матрица 1×1
        if (size == 1) {
            return mat[0][0];
        }
        // База рекурсии: матрица 2×2
        if (size == 2) {
            return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];
        }
        // Рекурсивный случай: разложение по первой строке
        int det = 0;
        for (int col = 0; col < size; col++) {
            // Знак алгебраического дополнения: (+) для чётных позиций, (-) для нечётных
            int sign = (col % 2 == 0) ? 1 : -1;
            // Рекурсивно вычисляем определитель минора
            det += sign * mat[0][col] * determinant(minor(mat, 0, col));
        }
        return det;
    }

    /**
     * Возвращает минор матрицы — подматрицу, полученную удалением заданной строки и столбца.
     * Используется при вычислении определителя и алгебраических дополнений.
     *
     * @param mat — исходная матрица.
     * @param r — индекс удаляемой строки.
     * @param c — индекс удаляемого столбца.
     * @return новая матрица размером (n-1)×(n-1).
     */
    private int[][] minor(int[][] mat, int r, int c) {
        int newSize = mat.length - 1;
        int[][] result = new int[newSize][newSize];
        // Копируем элементы, пропуская строку r и столбец c
        for (int i = 0, newRow = 0; i < mat.length; i++) {
            if (i == r) continue; // Пропускаем указанную строку
            for (int j = 0, newCol = 0; j < mat[i].length; j++) {
                if (j == c) continue; // Пропускаем указанный столбец
                result[newRow][newCol++] = mat[i][j];
            }
            newRow++;
        }
        return result;
    }

    /**
     * Вычисляет союзную (адъюнкт) матрицу — транспонированную матрицу алгебраических дополнений.
     * Алгебраическое дополнение A[i][j] = (-1)^(i+j) * det(minor(i,j)).
     * После построения матрицы кофакторов — транспонируем её.
     *
     * @param mat — исходная матрица.
     * @return союзная матрица (adjugate matrix).
     */
    private int[][] adjugateMatrix(int[][] mat) {
        int size = mat.length;
        int[][] cofactor = new int[size][size];
        // Заполняем матрицу алгебраических дополнений (кофакторов)
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                // Знак зависит от суммы индексов: чётная — плюс, нечётная — минус
                int sign = ((i + j) % 2 == 0) ? 1 : -1;
                // Определитель минора для позиции (i, j)
                cofactor[i][j] = sign * determinant(minor(mat, i, j));
            }
        }
        // Транспонируем матрицу кофакторов → получаем союзную матрицу
        int[][] adjugate = new int[size][size];
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                adjugate[i][j] = cofactor[j][i];
            }
        }
        return adjugate;
    }
}